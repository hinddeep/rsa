#include <iostream>
#include <math.h>
#include <chrono>
using namespace std;
using namespace std::chrono;

/*  
    First n primes: 300
    bit length: 16
    Miller Rabin Rounds: 40
    Processor: M1
    RAM: 16GB 
    Time Taken to generate p and q: ~100 micro seconds

    First n primes: 300
    bit length: 63
    Miller Rabin Rounds: 10
    Processor: M1
    RAM: 16GB 
    Time Taken to generate p and q: ~300ms
*/

unsigned long long int generateRandomNumber(long long int upper, long long int lower)
{
    /* seed the random number generator with the current timestamp (which is different everytime)
    so that every time we run the program, a new number is generated. Same number will be generated if
    we don't seed the RNG with different numbers */
    auto p1 = system_clock::now();
    // srand(time(NULL)); ---> if we use this we will have to discard 100s of thousands of numbers since
    // time(null) returns seconds from epoch. millions of instructions can be run in 1 second. so if we want to
    // continuously generate random numbers we need to use microseconds since epoch as the unit.
    // Doing so drastically improves performance. From a couple of minutes the execution times comes down to a few seconds.
    srand(duration_cast<microseconds>(p1.time_since_epoch()).count());
    long long int rndm = lower + (rand() % (upper - lower + 1)); // generate a random number in the closed range [lower, upper]

    // x & 1 is the fastest way to test whether or not a number is odd
    return (rndm & 1 ? rndm : rndm + 1); // even numbers cannot be prime so return only odd number
}

// generate first few natural primes using Atkin's sieve --> fastest
int *primeGenerator(int lim)
{
    bool arr[lim];

    // mark all numbers in the sieve as non-prime
    for (int i = 0; i < lim; i++)
    {
        arr[i] = false;
    }

    for (int i = 1; i * i < lim; i++)
    {
        for (int j = 1; j * j < lim; j++)
        {
            int a = (4 * i * i) + (j * j);
            if (a <= lim && (a % 12 == 1 || a % 12 == 5))
                arr[a] = true;

            a = (3 * i * i) + (j * j);
            if (a <= lim && a % 12 == 7)
                arr[a] = true;

            a = (3 * i * i) - (j * j);
            if (i > j && a <= lim && a % 12 == 11)
                arr[a] = true;
        }
    }

    // mark all the square and multiples of squares of the prime number as non-prime
    for (int i = 5; i * i < lim; i++)
    {
        if (arr[i] == 1)
        {
            for (int j = i * i; j < lim; j += i * i)
            {
                arr[j] = false;
            }
        }
    }

    // find out the number of prime numbers generated by atkin's sieve
    // used to allocate the least amount of memory to the primes array
    int len = 0;
    for (int i = 0; i < lim; i++)
    {
        if (arr[i] == 1)
            len++;
    }

    len += 3; // used to access the size of array in calling function
    int *primes = new int[len];
    primes[0] = len;
    primes[1] = 2;
    primes[2] = 3;

    for (int i = 5, j = 3; i < lim; i++)
    {
        if (arr[i] == 1)
        {
            primes[j++] = i;
        }
    }
    return primes;
}

long long int square_and_multiply(long long int base, int exponent, int modulo)
{
    long long int ans = 1;
    base = base % modulo; // reduce the base so that it is less than modulo
    while (exponent > 0)
    {
        if (exponent & 1) // if the exponent is odd
        {
            ans = (ans * base) % modulo;
        }
        exponent >>= 1; // divide by 2
        base = base * base % modulo;
    }
    return ans;
}

/* after every iteration the probability of the number not being a prime reduces by 1/4
    so after 1 iteration ---> 25%
    after 2 iterations ---> 6.25%
    after 3 iterations ---> 1.56%
    after 4 iterations ----> 0.39%
    after 5 iterations ----> 0.1%
    after 6 iterations ----> 0.02%
    after 7 iterations ----> 0.006%
    after 8 iterations ----> 0.0015%
    after 9 iterations ----> 0.0004%
    after 10 iterations ----> 0.0001%
    I will be using 10 rounds for this project. Error Rate: 10^-4 %
*/
bool millerRabin(long long int d, long long int number)
{
    bool result = false;

    // random number in the closed interval [2, number-2]
    unsigned long long int upper = number - 2;
    unsigned long long int lower = 2;
    unsigned long long int rndm = lower + rand() % (upper - lower + 1);
    long long int ans = square_and_multiply(rndm, d, number); // rndm ^ d % number

    if (ans == 1 || ans == number - 1)
    {
        return true;
    }

    while (d != number - 1)
    {
        ans = (ans * ans) % number;
        d *= 2;

        if (ans == 1)
        {
            return false;
        }

        if (ans == number - 1)
        {
            return true;
        }
    }
    return false;
}

bool checkIfPrime(long long int number, int itr_count)
{
    /* 
   these conditions are not applicable as our numbers range from 32768 to 65535
   if (number <= 1 || number == 4)  {
        return false;
    }
    if (number <= 3) {
        return true;
    } 
    */

    // let d = number - 1, calculate r from the eq: number = 2^d * r + 1
    long long int d = number - 1;
    while (!(d & 1))
    {            // continue until d is even
        d >>= 1; // fast division by 2
    }

    // perform specified number of iterations of the miller rabin test
    for (int i = 0; i < itr_count; i++)
    {
        if (!millerRabin(d, number))
        {
            return false;
        }
    }
    return true;
}

// long long int getGCD(long long int a, long long int b)
// {
//     if (a == 0)
//     {
//         cout << b << endl;
//         return b;
//     }
//     else
//         getGCD(b % a, a);
// }

long long int getProbablePrime(int lim, int itr_count, long long int nums_discarded, long long int upper, long long int lower)
{
    int *primes = primeGenerator(lim);
    long long int rndm;

    while (true)
    {
        rndm = generateRandomNumber(upper, lower);
        int i = 1;
        for (; i < primes[0]; i++)
        {
            if (rndm % primes[i] == 0) //&& primes[i]*primes[i] <= rndm
            {
                nums_discarded++;
                break;
            }
        }
        if (i == primes[0] && checkIfPrime(rndm, itr_count)) // now pass the number through miller rabin algo
        {
            break;
        }
    }
    delete[] primes;
    return rndm;
}

/**
 * Extended Euclidean algorithm used to compute 
 * modular inverse will always exiat as e and phi_N are coprime. in other words d exists
 */ 
void getPrivateExponent(long long int e, long long int phi_N, long long int *d, long long int *temp)
{
    if (e == 0)
    {
        *d = 0;
        *temp = 1;
        return;
    }
 
    long long int x1, y1;
    getPrivateExponent(phi_N % e, e, &x1, &y1);
 
    *d = y1 - (phi_N / e) * x1;
    *temp = x1;
    return;
}

int main()
{
    int lim;
    int precision;
    int itr_count;
    long long int p = 0;
    long long int q = 0;
    long long int N;
    long long int phi_N;
    long long int e;
    long long int d = 0;
    long long int temp = 0;
    static int nums_discarded = 0;
    string msg = "";

    cout << "Enter the number of first few primes to be generated:" << endl;
    cin >> lim;

    cout << "Enter the bit length of the number to generated:" << endl;
    cin >> precision;

    cout << "Enter the number of iterations for the miller rabin test:" << endl;
    cin >> itr_count;

    auto t1 = high_resolution_clock::now(); // start the timer

    long long int upper = pow(2, precision) - 1;
    long long int lower = pow(2, (precision - 1)) + 1;
    p = getProbablePrime(lim, itr_count, nums_discarded, upper, lower);
    q = getProbablePrime(lim, itr_count, nums_discarded, upper, lower);

    N = p * q;
    phi_N = (p - 1) * (q - 1);
    // e is a random prime number of at least 16 bits but less than phi_N. So e and phi_N are automatically coprime numbers
    e = getProbablePrime(lim, itr_count, nums_discarded, lower, phi_N); 
    getPrivateExponent(e, phi_N, &d, &temp);
    
    auto t2 = high_resolution_clock::now(); // stop the timer
    auto duration_micro_s = duration_cast<microseconds>(t2 - t1);
    auto duration_ms = duration_cast<milliseconds>(t2 - t1);
   
    cout << "random prime number 1: " << p << endl;
    cout << "random prime number 2: " << q << endl;
    cout << "N: " << N << endl;
    cout << "phi_N: " << phi_N << endl;
    cout << "e: " << e << endl;
    cout << "d: " << d << endl;
    cout << "random numbers discarded: " << nums_discarded << endl;
    cout << "duration in micro seconds: " << duration_micro_s.count() << endl;
    cout << "duration in milli seconds: " << duration_ms.count() << endl;
    return 0;
}